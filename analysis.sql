-- phase 1 : Exploratory Analysis
-- total revenue generated by food delivery app
-- The company wants to know:
-- 1.Total Revenue

select sum(order_amount - discount) as total_revenue from orders;

-- 2. Total Orders Per City

select r.city, count(o.order_id) as total_orders
from orders o join restaurants r on o.restaurant_id = r.restaurant_id
group by r.city
order by total_orders desc;

-- 3. Top 10 Customers by Spending

select c.name, sum(o.order_amount - o.discount) as total_spent
from customers c join orders o on o.customer_id = c.customer_id
group by c.customer_id
order by total_spent desc
limit 10;


-- PHASE 2 — CUSTOMER SEGMENTATION
-- 1. Customer Category (Gold/Silver/Bronze)

select c.name, sum(o.order_amount - o.discount) as total_spent,
case when sum(o.order_amount - o.discount) >= 5000 then 'Gold'
     when sum(o.order_amount - o.discount) >= 2000 then 'Silver'
     else 'Bronze' end as customer_category
from customers c 
join orders o on o.customer_id = c.customer_id
group by c.customer_id;

-- PHASE 3 — RESTAURANT PERFORMANCE
-- 1.Top 10 Restaurants by Revenue

select r.rest_name, r.city, 
sum(o.order_amount - o.discount) as total_revenue
from restaurants r join orders o on o.restaurant_id = r.restaurant_id
group by r.restaurant_id, r.city
order by total_revenue desc
limit 10
;

-- 2. Average Rating vs Revenue

select r.rest_name, round(avg(r.rating),2) as avg_rating,
sum(o.order_amount - o.discount) as total_revenue
from restaurants r join orders o on o.restaurant_id = r.restaurant_id
group by r.restaurant_id, r.city
order by total_revenue desc
;

-- PHASE 4 — DELIVERY ANALYSIS
-- 1. Average Delivery Time Per City

select r.city, 
round(avg(o.delivery_time),2) as avg_delivery_time
from restaurants r join orders o on o.restaurant_id = r.restaurant_id
group by r.city
order by avg_delivery_time
;

-- 2.Late Deliveries (Above 45 Minutes)
select r.city, 
round(avg(o.delivery_time),2) as avg_delivery_time
from restaurants r join orders o on o.restaurant_id = r.restaurant_id
-- where round(avg(o.delivery_time),2) > 45
group by r.city
having round(avg(o.delivery_time),2) > 45
;


-- PHASE 5 — PAYMENT & DISCOUNT ANALYSIS
-- 1.Payment Method Distribution
-- count orders for each payment_type

select 
payment_method,
count(*) as no_of_orders
from orders
group by payment_method
order by no_of_orders desc;

-- 2. Discount Impact on Revenue
-- case statement - > 0 = discounted otherwise not_discounted

select order_amount,
case when discount > 100 then "Heavy_Discounted_product"
when discount between 1 and 100 then "Low_Discounted_product"
else "Non_discounted_product"
end as discount_category,
sum(order_amount - discount) as total_revenue
from orders
group by order_amount, discount
;

-- PHASE 6 — ADVANCED SQL
-- 1.Monthly Revenue Using CTE

with monthly_revenue as (
select month(order_date) as month,
sum(order_amount - discount) as total_revenue from orders
group by month(order_date)
)
select month, total_revenue
from monthly_revenue
order by month;


-- 2.Rank Restaurants by Revenue (Window Function)

select rest_name, city,
sum(order_amount - discount) as total_revenue,
rank() over (order by sum(order_amount - discount) desc) as revenue_rank
from restaurants r join orders o on r.restaurant_id = o.restaurant_id
group by r.restaurant_id, r.city
order by total_revenue desc
;

-- 3.Above Average Revenue Restaurants (Subquery)

select r.rest_name, r.city,
sum(order_amount - discount) as total_revenue
from restaurants r join orders o on r.restaurant_id = o.restaurant_id
group by r.restaurant_id
having sum(order_amount - discount) > (
select avg(order_amount - discount) as avg_revenue
from restaurants r join orders o on r.restaurant_id = o.restaurant_id
);


-- PHASE 7 — DATABASE OBJECTS
-- 1.Create Revenue View

create view revenue_view as
select 
r.restaurant_id,
r.rest_name, 
r.city,
sum(o.order_amount - o.discount) as total_revenue
from restaurants r join orders o on r.restaurant_id = o.restaurant_id
group by r.restaurant_id, r.rest_namer.city
order by total_revenue desc
;

select * from revenue_view;

-- 2.Stored Procedure: Get Top N Restaurant

CREATE PROCEDURE GetTopNRestaurants(IN top_n INT)
BEGIN
    SELECT r.rest_name, r.rating, count(o.order_id) as total_orders
    FROM restaurants r
    join orders o on o.restaurant_id = r.restaurant_id
    group by r.restaurant_id
    ORDER BY total_orders  DESC
    LIMIT top_n;
END;
call GetTopNRestaurants(10);

-- PHASE 8-- Performance Optimization
-- Index on order_date (for monthly reports)

create index ind_order_date on orders(order_date);

-- Index on customer_name (for joins)

create index ind_customer_name on customers(name);

-- Index on restaurant_name

create index ind_restaurant_name on restaurants(rest_name);

-- PHASE 9 —Automation Logic
-- TRIGGER 1 — Auto log high value orders (above 1000)

create table high_value_orders_log (
log_id int primary key auto_increment,
order_id int,
customer_id int,
restaurant_id int,
order_amount decimal(10,2),
log_date datetime default current_timestamp
);
create trigger trg_high_valoue_order
after insert on orders
for each row
begin
    if new.order_amount > 1000 then
        insert into high_value_orders_log (order_id, customer_id, restaurant_id, order_amount)
        values (new.order_id, new.customer_id, new.restaurant_id, new.order_amount);
    end if;
end;

insert into orders values (1010, 215, 238, '2024-06-01 12:00:00', 1500.00, 100.00, 'Credit Card', 30);
insert into orders values (1011, 216, 239, '2024-06-02 13:00:00', 8000.00, 50.00, 'Cash', 25);
insert into orders values (1021, 236, 246, '2024-06-03 14:00:00', 2000.00, 20.00, 'UPI', 20);
insert into orders values (1022, 237, 247, '2024-06-04 15:00:00', 1455.00, 30.00, 'Debit Card', 35);
insert into orders values (1023, 238, 248, '2024-06-05 16:00:00', 2120.00, 20.00, 'UPI', 40);

select * from high_value_orders_log;

-- TRIGGER 2 - Negative discount

create trigger trg_negative_discount
before insert on orders
for each row
begin
     if new.discount < 0 then
        set new.discount = 0;
     end if;
end;

insert into orders values (1012, 217, 240, '2024-06-03 14:00:00', 500.00, -20.00, 'UPI', 20);
insert into orders values (1013, 218, 241, '2024-06-04 15:00:00', 600.00, -30.00, 'Debit Card', 35);

select * from orders where order_id = 1012;

-- TRIGGER 2 — Delivery Delay Warning
create table delivery_delay_log (
log_id int primary key auto_increment,
order_id int,
customer_id int,
restaurant_id int,
delivery_time int,
created_at timestamp default current_timestamp
);

create trigger log_delivery_delay
after insert on orders
for each row
begin
    if new.delivery_time > 45 then
        insert into delivery_delay_log (order_id, customer_id, restaurant_id, delivery_time)
        values (new.order_id, new.customer_id, new.restaurant_id, new.delivery_time);
    end if;
end;

insert into orders values (1016, 231, 241, '2024-06-04 15:00:00', 600.00, 30.00, 'Debit Card', 50);
insert into orders values (1017, 232, 242, '2024-06-05 16:00:00', 700.00, 20.00, 'UPI', 65);
insert into orders values (1018, 233, 243, '2024-06-06 17:00:00', 800.00, 10.00, 'Cash', 48);
insert into orders values (1019, 234, 244, '2024-06-07 18:00:00', 900.00, 0.00, 'Credit Card', 55);
insert into orders values (1020, 235, 245, '2024-06-08 19:00:00', 1000.00, 50.00, 'UPI', 60);

select * from delivery_delay_log;

-- sql for dashboard(extra analysis)

-- Top 10 most frequently ordered items
select oi.item_name,
count(o.order_id) as times_bought
from order_items oi
join orders o on o.order_id = oi.order_id
group by oi.item_name
order by times_bought desc
limit 10; 

-- Top 10 items which sell highest volume
select item_name,
sum(quantity) as units_sold
from order_items
group by item_name
order by units_sold desc
limit 10;

-- total orders 
select count(order_id) as total_orders from orders;

-- total customers
select count(customer_id) as total_customers from customers;

-- average order value
select sum(order_amount - discount)/count(order_id) as avg_order_value from orders;

-- High Revenue Items
select item_name,
sum(price * quantity) as total_revenue
from order_items
group by item_name
order by total_revenue desc
limit 10;

-- REPEAT CUSTOMERS
SELECT customer_id,
       COUNT(order_id) AS total_orders
FROM orders
GROUP BY customer_id
HAVING COUNT(order_id) > 1
ORDER BY total_orders DESC;

-- customer segmentation by city and gender
SELECT city, gender,
       COUNT(customer_id) AS total_customers
FROM customers
GROUP BY city, gender;

-- discount impact on revenue

select 
    CASE 
        WHEN discount = 0 THEN 'No Discount'
        ELSE 'Discount Applied'
    END AS discount_status,
    COUNT(order_id) AS total_orders,
    SUM(order_amount - discount) AS total_revenue
from orders
group by discount_status;

-- agent performance

SELECT da.agent_name, da.city,
       COUNT(o.order_id) AS total_deliveries,
       AVG(o.delivery_time) AS avg_delivery_time
FROM delivery_agents da
JOIN orders o ON da.agent_id = o.restaurant_id
GROUP BY da.agent_id
ORDER BY total_deliveries DESC;

-- underperforming restaurants

SELECT total_orders,
       COUNT(*) AS restaurant_count
FROM (
    SELECT r.restaurant_id,
           COUNT(o.order_id) AS total_orders
    FROM restaurants r
    LEFT JOIN orders o 
        ON r.restaurant_id = o.restaurant_id
    GROUP BY r.restaurant_id
) AS sub
GROUP BY total_orders
ORDER BY total_orders;


-- Inactive Restaurants by City
SELECT city,
       COUNT(*) AS less_order_restaurants
FROM restaurants r
LEFT JOIN orders o 
    ON r.restaurant_id = o.restaurant_id
WHERE o.order_id IS NULL
GROUP BY city;

-- total restaurants
SELECT COUNT(restaurant_id) AS total_restaurants FROM restaurants;

-- average delivery time
select round(avg(delivery_time),2) as avg_delivery_time from orders;